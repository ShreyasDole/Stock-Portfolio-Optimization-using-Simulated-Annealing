# -*- coding: utf-8 -*-
"""Stock Data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1va68VmSylXcCxr_wentNkbqUkAYviZws
"""

import numpy as np
import random
import yfinance as yf
import pandas as pd

# List of stock tickers
stocks = ['RELIANCE.NS', 'INFY.NS', 'HDFCBANK.NS', 'LT.NS', 'HINDUNILVR.NS',
          'ASIANPAINT.NS', 'MARUTI.NS', 'TITAN.NS', 'TATAMOTORS.NS', 'SUNPHARMA.NS']

# Initialize a DataFrame to store stock data
stock_data = pd.DataFrame()

# Retrieve 20 years of daily stock data for each stock
for stock in stocks:
    data = yf.download(stock, start="2002-04-01", end="2023-04-01")
    stock_data[stock + '_Close'] = data['Close']
    stock_data[stock + '_Daily_Return'] = data['Close'].pct_change()

# Calculate average return for each stock
average_return = stock_data.filter(like='_Daily_Return').mean()

# Define objective function (portfolio return)
def objective(weights):
    return np.sum(average_return * weights)  # Positive because we want to maximize return

# Define initial temperature and cooling rate
initial_temperature = 100.0
cooling_rate = 0.95

# Define initial solution (random weights)
current_solution = np.array([random.uniform(0, 1) for _ in range(len(stocks))])
current_solution /= np.sum(current_solution)  # Ensure weights sum to 1
current_energy = objective(current_solution)

# Initialize best solution and energy
best_solution = current_solution
best_energy = current_energy

# Simulated annealing optimization loop
while initial_temperature > 0.1:
    # Generate a random neighboring solution
    neighbor_solution = np.array([random.uniform(0, 1) for _ in range(len(stocks))])
    neighbor_solution /= np.sum(neighbor_solution)  # Ensure weights sum to 1
    neighbor_energy = objective(neighbor_solution)

    # Accept the neighbor solution with probability based on temperature and energy difference
    if neighbor_energy > current_energy or random.random() < np.exp((neighbor_energy - current_energy) / initial_temperature):
        current_solution = neighbor_solution
        current_energy = neighbor_energy

    # Update best solution if applicable
    if neighbor_energy > best_energy:
        best_solution = neighbor_solution
        best_energy = neighbor_energy

    # Cool down the temperature
    initial_temperature *= cooling_rate

# Total investment amount in INR
total_investment_inr = 100000  # Change this to your desired total investment amount

# Calculate the amount of investment for each stock based on optimized portfolio weights
investment_per_stock = best_solution * total_investment_inr

# Calculate the portfolio's expected return (not annualized yet)
optimized_portfolio_return = best_energy

# Display optimized portfolio weights
print("Optimized Portfolio Weights:")
for i, stock in enumerate(stocks):
    print(stock + ':', "{:.2f}%".format(best_solution[i] * 100))

# Display the expected return of each stock
print("\nExpected Return of Each Stock:")
for i, stock in enumerate(stocks):
    expected_return_stock = average_return[stock + '_Daily_Return'] * 252  # 252 trading days per year
    print(stock + ':', "{:.2f}%".format(expected_return_stock * 100))

# Display the investment for each stock in percentage and INR
print("\nInvestment for Each Stock:")
for i, stock in enumerate(stocks):
    percentage = best_solution[i] * 100
    print(stock + ':', "{:.2f}% - INR {:.2f}".format(percentage, investment_per_stock[i]))

